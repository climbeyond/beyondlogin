/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package sh.ory.api

import sh.ory.model.BatchPatchIdentitiesResponse
import sh.ory.model.CreateIdentityBody
import sh.ory.model.CreateRecoveryCodeForIdentityBody
import sh.ory.model.CreateRecoveryLinkForIdentityBody
import sh.ory.model.ErrorGeneric
import sh.ory.model.Identity
import sh.ory.model.IdentitySchemaContainer
import sh.ory.model.JsonPatch
import sh.ory.model.PatchIdentitiesBody
import sh.ory.model.RecoveryCodeForIdentity
import sh.ory.model.RecoveryLinkForIdentity
import sh.ory.model.Session
import sh.ory.model.UpdateIdentityBody

import org.openapitools.client.infrastructure.*
import io.ktor.client.HttpClient
import io.ktor.client.HttpClientConfig
import io.ktor.client.request.forms.formData
import io.ktor.client.engine.HttpClientEngine
import kotlinx.serialization.json.Json
import io.ktor.http.ParametersBuilder
import kotlinx.serialization.*
import kotlinx.serialization.descriptors.*
import kotlinx.serialization.encoding.*

open class IdentityApi : ApiClient {

    constructor(
        baseUrl: String = ApiClient.BASE_URL,
        httpClientEngine: HttpClientEngine? = null,
        httpClientConfig: ((HttpClientConfig<*>) -> Unit)? = null,
        jsonSerializer: Json = ApiClient.JSON_DEFAULT
    ) : super(baseUrl = baseUrl, httpClientEngine = httpClientEngine, httpClientConfig = httpClientConfig, jsonBlock = jsonSerializer)

    constructor(
        baseUrl: String,
        httpClient: HttpClient
    ): super(baseUrl = baseUrl, httpClient = httpClient)

    /**
     * Create and deletes multiple identities
     * Creates or delete multiple [identities](https://www.ory.sh/docs/kratos/concepts/identity-user-model). This endpoint can also be used to [import credentials](https://www.ory.sh/docs/kratos/manage-identities/import-user-accounts-identities) for instance passwords, social sign in configurations or multifactor methods.
     * @param patchIdentitiesBody  (optional)
     * @return BatchPatchIdentitiesResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun batchPatchIdentities(patchIdentitiesBody: PatchIdentitiesBody? = null): HttpResponse<BatchPatchIdentitiesResponse> {

        val localVariableAuthNames = listOf<String>("oryAccessToken")

        val localVariableBody = patchIdentitiesBody

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PATCH,
            "/admin/identities",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Create an Identity
     * Create an [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model).  This endpoint can also be used to [import credentials](https://www.ory.sh/docs/kratos/manage-identities/import-user-accounts-identities) for instance passwords, social sign in configurations or multifactor methods.
     * @param createIdentityBody  (optional)
     * @return Identity
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun createIdentity(createIdentityBody: CreateIdentityBody? = null): HttpResponse<Identity> {

        val localVariableAuthNames = listOf<String>("oryAccessToken")

        val localVariableBody = createIdentityBody

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/admin/identities",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Create a Recovery Code
     * This endpoint creates a recovery code which should be given to the user in order for them to recover (or activate) their account.
     * @param createRecoveryCodeForIdentityBody  (optional)
     * @return RecoveryCodeForIdentity
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun createRecoveryCodeForIdentity(createRecoveryCodeForIdentityBody: CreateRecoveryCodeForIdentityBody? = null): HttpResponse<RecoveryCodeForIdentity> {

        val localVariableAuthNames = listOf<String>("oryAccessToken")

        val localVariableBody = createRecoveryCodeForIdentityBody

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/admin/recovery/code",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Create a Recovery Link
     * This endpoint creates a recovery link which should be given to the user in order for them to recover (or activate) their account.
     * @param createRecoveryLinkForIdentityBody  (optional)
     * @return RecoveryLinkForIdentity
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun createRecoveryLinkForIdentity(createRecoveryLinkForIdentityBody: CreateRecoveryLinkForIdentityBody? = null): HttpResponse<RecoveryLinkForIdentity> {

        val localVariableAuthNames = listOf<String>("oryAccessToken")

        val localVariableBody = createRecoveryLinkForIdentityBody

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/admin/recovery/link",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Delete an Identity
     * Calling this endpoint irrecoverably and permanently deletes the [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model) given its ID. This action can not be undone. This endpoint returns 204 when the identity was deleted or when the identity was not found, in which case it is assumed that is has been deleted already.
     * @param id ID is the identity&#39;s ID.
     * @return void
     */
    open suspend fun deleteIdentity(id: kotlin.String): HttpResponse<Unit> {

        val localVariableAuthNames = listOf<String>("oryAccessToken")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/admin/identities/{id}".replace("{" + "id" + "}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * enum for parameter type
     */
    @Serializable
    enum class TypeDeleteIdentityCredentials(val value: kotlin.String) {
        
        @SerialName(value = "totp")
        TOTP("totp"),
        
        @SerialName(value = "webauthn")
        WEBAUTHN("webauthn"),
        
        @SerialName(value = "lookup")
        LOOKUP("lookup")
        
    }

    /**
     * Delete a credential for a specific identity
     * Delete an [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model) credential by its type You can only delete second factor (aal2) credentials.
     * @param id ID is the identity&#39;s ID.
     * @param type Type is the credential&#39;s Type. One of totp, webauthn, lookup
     * @return void
     */
    open suspend fun deleteIdentityCredentials(id: kotlin.String, type: TypeDeleteIdentityCredentials): HttpResponse<Unit> {

        val localVariableAuthNames = listOf<String>("oryAccessToken")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/admin/identities/{id}/credentials/{type}".replace("{" + "id" + "}", "$id").replace("{" + "type" + "}", "$type"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Delete &amp; Invalidate an Identity&#39;s Sessions
     * Calling this endpoint irrecoverably and permanently deletes and invalidates all sessions that belong to the given Identity.
     * @param id ID is the identity&#39;s ID.
     * @return void
     */
    open suspend fun deleteIdentitySessions(id: kotlin.String): HttpResponse<Unit> {

        val localVariableAuthNames = listOf<String>("oryAccessToken")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/admin/identities/{id}/sessions".replace("{" + "id" + "}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Deactivate a Session
     * Calling this endpoint deactivates the specified session. Session data is not deleted.
     * @param id ID is the session&#39;s ID.
     * @return void
     */
    open suspend fun disableSession(id: kotlin.String): HttpResponse<Unit> {

        val localVariableAuthNames = listOf<String>("oryAccessToken")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/admin/sessions/{id}".replace("{" + "id" + "}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Extend a Session
     * Calling this endpoint extends the given session ID. If &#x60;session.earliest_possible_extend&#x60; is set it will only extend the session after the specified time has passed.  Retrieve the session ID from the &#x60;/sessions/whoami&#x60; endpoint / &#x60;toSession&#x60; SDK method.
     * @param id ID is the session&#39;s ID.
     * @return Session
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun extendSession(id: kotlin.String): HttpResponse<Session> {

        val localVariableAuthNames = listOf<String>("oryAccessToken")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PATCH,
            "/admin/sessions/{id}/extend".replace("{" + "id" + "}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * enum for parameter includeCredential
     */
    @Serializable
    enum class IncludeCredentialGetIdentity(val value: kotlin.String) {
        
        @SerialName(value = "password")
        PASSWORD("password"),
        
        @SerialName(value = "totp")
        TOTP("totp"),
        
        @SerialName(value = "oidc")
        OIDC("oidc"),
        
        @SerialName(value = "webauthn")
        WEBAUTHN("webauthn"),
        
        @SerialName(value = "lookup_secret")
        LOOKUP_SECRET("lookup_secret")
        
    }

    /**
     * Get an Identity
     * Return an [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model) by its ID. You can optionally include credentials (e.g. social sign in connections) in the response by using the &#x60;include_credential&#x60; query parameter.
     * @param id ID must be set to the ID of identity you want to get
     * @param includeCredential Include Credentials in Response  Include any credential, for example &#x60;password&#x60; or &#x60;oidc&#x60;, in the response. When set to &#x60;oidc&#x60;, This will return the initial OAuth 2.0 Access Token, OAuth 2.0 Refresh Token and the OpenID Connect ID Token if available. (optional)
     * @return Identity
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getIdentity(id: kotlin.String, includeCredential: kotlin.collections.List<IncludeCredentialGetIdentity>? = null): HttpResponse<Identity> {

        val localVariableAuthNames = listOf<String>("oryAccessToken")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        includeCredential?.apply { localVariableQuery["include_credential"] = toMultiValue(this, "multi") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/admin/identities/{id}".replace("{" + "id" + "}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get Identity JSON Schema
     * Return a specific identity schema.
     * @param id ID must be set to the ID of schema you want to get
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getIdentitySchema(id: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/schemas/{id}".replace("{" + "id" + "}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * enum for parameter expand
     */
    @Serializable
    enum class ExpandGetSession(val value: kotlin.String) {
        
    }

    /**
     * Get Session
     * This endpoint is useful for:  Getting a session object with all specified expandables that exist in an administrative context.
     * @param id ID is the session&#39;s ID.
     * @param expand ExpandOptions is a query parameter encoded list of all properties that must be expanded in the Session. Example - ?expand&#x3D;Identity&amp;expand&#x3D;Devices If no value is provided, the expandable properties are skipped. (optional)
     * @return Session
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getSession(id: kotlin.String, expand: kotlin.collections.List<ExpandGetSession>? = null): HttpResponse<Session> {

        val localVariableAuthNames = listOf<String>("oryAccessToken")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        expand?.apply { localVariableQuery["expand"] = toMultiValue(this, "multi") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/admin/sessions/{id}".replace("{" + "id" + "}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * List Identities
     * Lists all [identities](https://www.ory.sh/docs/kratos/concepts/identity-user-model) in the system.
     * @param perPage Items per Page  This is the number of items per page. (optional, default to 250L)
     * @param page Pagination Page  This value is currently an integer, but it is not sequential. The value is not the page number, but a reference. The next page can be any number and some numbers might return an empty list.  For example, page 2 might not follow after page 1. And even if page 3 and 5 exist, but page 4 might not exist. (optional, default to 1L)
     * @param credentialsIdentifier CredentialsIdentifier is the identifier (username, email) of the credentials to look up. (optional)
     * @return kotlin.Array<Identity>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun listIdentities(perPage: kotlin.Long? = 250L, page: kotlin.Long? = 1L, credentialsIdentifier: kotlin.String? = null): HttpResponse<kotlin.Array<Identity>> {

        val localVariableAuthNames = listOf<String>("oryAccessToken")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        perPage?.apply { localVariableQuery["per_page"] = listOf("$perPage") }
        page?.apply { localVariableQuery["page"] = listOf("$page") }
        credentialsIdentifier?.apply { localVariableQuery["credentials_identifier"] = listOf("$credentialsIdentifier") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/admin/identities",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<ListIdentitiesResponse>().map { value.toTypedArray() }
    }

    @Serializable(ListIdentitiesResponse.Companion::class)
    private class ListIdentitiesResponse(val value: List<Identity>) {
        companion object : KSerializer<ListIdentitiesResponse> {
            private val serializer: KSerializer<List<Identity>> = serializer<List<Identity>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: ListIdentitiesResponse) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = ListIdentitiesResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * Get all Identity Schemas
     * Returns a list of all identity schemas currently in use.
     * @param perPage Items per Page  This is the number of items per page. (optional, default to 250L)
     * @param page Pagination Page  This value is currently an integer, but it is not sequential. The value is not the page number, but a reference. The next page can be any number and some numbers might return an empty list.  For example, page 2 might not follow after page 1. And even if page 3 and 5 exist, but page 4 might not exist. (optional, default to 1L)
     * @return kotlin.Array<IdentitySchemaContainer>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun listIdentitySchemas(perPage: kotlin.Long? = 250L, page: kotlin.Long? = 1L): HttpResponse<kotlin.Array<IdentitySchemaContainer>> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        perPage?.apply { localVariableQuery["per_page"] = listOf("$perPage") }
        page?.apply { localVariableQuery["page"] = listOf("$page") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/schemas",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<ListIdentitySchemasResponse>().map { value.toTypedArray() }
    }

    @Serializable(ListIdentitySchemasResponse.Companion::class)
    private class ListIdentitySchemasResponse(val value: List<IdentitySchemaContainer>) {
        companion object : KSerializer<ListIdentitySchemasResponse> {
            private val serializer: KSerializer<List<IdentitySchemaContainer>> = serializer<List<IdentitySchemaContainer>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: ListIdentitySchemasResponse) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = ListIdentitySchemasResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * List an Identity&#39;s Sessions
     * This endpoint returns all sessions that belong to the given Identity.
     * @param id ID is the identity&#39;s ID.
     * @param perPage Items per Page  This is the number of items per page. (optional, default to 250L)
     * @param page Pagination Page  This value is currently an integer, but it is not sequential. The value is not the page number, but a reference. The next page can be any number and some numbers might return an empty list.  For example, page 2 might not follow after page 1. And even if page 3 and 5 exist, but page 4 might not exist. (optional, default to 1L)
     * @param active Active is a boolean flag that filters out sessions based on the state. If no value is provided, all sessions are returned. (optional)
     * @return kotlin.Array<Session>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun listIdentitySessions(id: kotlin.String, perPage: kotlin.Long? = 250L, page: kotlin.Long? = 1L, active: kotlin.Boolean? = null): HttpResponse<kotlin.Array<Session>> {

        val localVariableAuthNames = listOf<String>("oryAccessToken")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        perPage?.apply { localVariableQuery["per_page"] = listOf("$perPage") }
        page?.apply { localVariableQuery["page"] = listOf("$page") }
        active?.apply { localVariableQuery["active"] = listOf("$active") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/admin/identities/{id}/sessions".replace("{" + "id" + "}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<ListIdentitySessionsResponse>().map { value.toTypedArray() }
    }

    @Serializable(ListIdentitySessionsResponse.Companion::class)
    private class ListIdentitySessionsResponse(val value: List<Session>) {
        companion object : KSerializer<ListIdentitySessionsResponse> {
            private val serializer: KSerializer<List<Session>> = serializer<List<Session>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: ListIdentitySessionsResponse) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = ListIdentitySessionsResponse(serializer.deserialize(decoder))
        }
    }


    /**
     * enum for parameter expand
     */
    @Serializable
    enum class ExpandListSessions(val value: kotlin.String) {
        
    }

    /**
     * List All Sessions
     * Listing all sessions that exist.
     * @param pageSize Items per Page  This is the number of items per page to return. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to 250L)
     * @param pageToken Next Page Token  The next page token. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional)
     * @param active Active is a boolean flag that filters out sessions based on the state. If no value is provided, all sessions are returned. (optional)
     * @param expand ExpandOptions is a query parameter encoded list of all properties that must be expanded in the Session. If no value is provided, the expandable properties are skipped. (optional)
     * @return kotlin.Array<Session>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun listSessions(pageSize: kotlin.Long? = 250L, pageToken: kotlin.String? = null, active: kotlin.Boolean? = null, expand: kotlin.collections.List<ExpandListSessions>? = null): HttpResponse<kotlin.Array<Session>> {

        val localVariableAuthNames = listOf<String>("oryAccessToken")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        pageSize?.apply { localVariableQuery["page_size"] = listOf("$pageSize") }
        pageToken?.apply { localVariableQuery["page_token"] = listOf("$pageToken") }
        active?.apply { localVariableQuery["active"] = listOf("$active") }
        expand?.apply { localVariableQuery["expand"] = toMultiValue(this, "multi") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/admin/sessions",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<ListSessionsResponse>().map { value.toTypedArray() }
    }

    @Serializable(ListSessionsResponse.Companion::class)
    private class ListSessionsResponse(val value: List<Session>) {
        companion object : KSerializer<ListSessionsResponse> {
            private val serializer: KSerializer<List<Session>> = serializer<List<Session>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: ListSessionsResponse) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = ListSessionsResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * Patch an Identity
     * Partially updates an [identity&#39;s](https://www.ory.sh/docs/kratos/concepts/identity-user-model) field using [JSON Patch](https://jsonpatch.com/). The fields &#x60;id&#x60;, &#x60;stateChangedAt&#x60; and &#x60;credentials&#x60; can not be updated using this method.
     * @param id ID must be set to the ID of identity you want to update
     * @param jsonPatch  (optional)
     * @return Identity
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun patchIdentity(id: kotlin.String, jsonPatch: kotlin.Array<JsonPatch>? = null): HttpResponse<Identity> {

        val localVariableAuthNames = listOf<String>("oryAccessToken")

        val localVariableBody = PatchIdentityRequest(jsonPatch?.asList() ?: arrayListOf())

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PATCH,
            "/admin/identities/{id}".replace("{" + "id" + "}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }

    @Serializable(PatchIdentityRequest.Companion::class)
    private class PatchIdentityRequest(val value: List<JsonPatch>) {
        companion object : KSerializer<PatchIdentityRequest> {
            private val serializer: KSerializer<List<JsonPatch>> = serializer<List<JsonPatch>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: PatchIdentityRequest) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = PatchIdentityRequest(serializer.deserialize(decoder))
        }
    }

    /**
     * Update an Identity
     * This endpoint updates an [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model). The full identity payload (except credentials) is expected. It is possible to update the identity&#39;s credentials as well.
     * @param id ID must be set to the ID of identity you want to update
     * @param updateIdentityBody  (optional)
     * @return Identity
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun updateIdentity(id: kotlin.String, updateIdentityBody: UpdateIdentityBody? = null): HttpResponse<Identity> {

        val localVariableAuthNames = listOf<String>("oryAccessToken")

        val localVariableBody = updateIdentityBody

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/admin/identities/{id}".replace("{" + "id" + "}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



}
