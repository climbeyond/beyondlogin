/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package sh.ory.api

import sh.ory.model.BatchPatchIdentitiesResponse
import sh.ory.model.CreateIdentityBody
import sh.ory.model.CreateRecoveryCodeForIdentityBody
import sh.ory.model.CreateRecoveryLinkForIdentityBody
import sh.ory.model.ErrorGeneric
import sh.ory.model.Identity
import sh.ory.model.IdentitySchemaContainer
import sh.ory.model.JsonPatch
import sh.ory.model.PatchIdentitiesBody
import sh.ory.model.RecoveryCodeForIdentity
import sh.ory.model.RecoveryLinkForIdentity
import sh.ory.model.Session
import sh.ory.model.UpdateIdentityBody

import org.openapitools.client.infrastructure.*
import io.ktor.client.HttpClient
import io.ktor.client.HttpClientConfig
import io.ktor.client.request.forms.formData
import io.ktor.client.engine.HttpClientEngine
import kotlinx.serialization.json.Json
import io.ktor.http.ParametersBuilder
import kotlinx.serialization.*
import kotlinx.serialization.descriptors.*
import kotlinx.serialization.encoding.*

open class IdentityApi : ApiClient {

    constructor(
        baseUrl: String = ApiClient.BASE_URL,
        httpClientEngine: HttpClientEngine? = null,
        httpClientConfig: ((HttpClientConfig<*>) -> Unit)? = null,
        jsonSerializer: Json = ApiClient.JSON_DEFAULT
    ) : super(baseUrl = baseUrl, httpClientEngine = httpClientEngine, httpClientConfig = httpClientConfig, jsonBlock = jsonSerializer)

    constructor(
        baseUrl: String,
        httpClient: HttpClient
    ): super(baseUrl = baseUrl, httpClient = httpClient)

    /**
     * Create multiple identities
     * Creates multiple [identities](https://www.ory.sh/docs/kratos/concepts/identity-user-model). This endpoint can also be used to [import credentials](https://www.ory.sh/docs/kratos/manage-identities/import-user-accounts-identities) for instance passwords, social sign in configurations or multifactor methods.
     * @param patchIdentitiesBody  (optional)
     * @return BatchPatchIdentitiesResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun batchPatchIdentities(patchIdentitiesBody: PatchIdentitiesBody? = null): HttpResponse<BatchPatchIdentitiesResponse> {

        val localVariableAuthNames = listOf<String>("oryAccessToken")

        val localVariableBody = patchIdentitiesBody

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PATCH,
            "/admin/identities",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Create an Identity
     * Create an [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model).  This endpoint can also be used to [import credentials](https://www.ory.sh/docs/kratos/manage-identities/import-user-accounts-identities) for instance passwords, social sign in configurations or multifactor methods.
     * @param createIdentityBody  (optional)
     * @return Identity
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun createIdentity(createIdentityBody: CreateIdentityBody? = null): HttpResponse<Identity> {

        val localVariableAuthNames = listOf<String>("oryAccessToken")

        val localVariableBody = createIdentityBody

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/admin/identities",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Create a Recovery Code
     * This endpoint creates a recovery code which should be given to the user in order for them to recover (or activate) their account.
     * @param createRecoveryCodeForIdentityBody  (optional)
     * @return RecoveryCodeForIdentity
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun createRecoveryCodeForIdentity(createRecoveryCodeForIdentityBody: CreateRecoveryCodeForIdentityBody? = null): HttpResponse<RecoveryCodeForIdentity> {

        val localVariableAuthNames = listOf<String>("oryAccessToken")

        val localVariableBody = createRecoveryCodeForIdentityBody

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/admin/recovery/code",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Create a Recovery Link
     * This endpoint creates a recovery link which should be given to the user in order for them to recover (or activate) their account.
     * @param returnTo  (optional)
     * @param createRecoveryLinkForIdentityBody  (optional)
     * @return RecoveryLinkForIdentity
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun createRecoveryLinkForIdentity(returnTo: kotlin.String? = null, createRecoveryLinkForIdentityBody: CreateRecoveryLinkForIdentityBody? = null): HttpResponse<RecoveryLinkForIdentity> {

        val localVariableAuthNames = listOf<String>("oryAccessToken")

        val localVariableBody = createRecoveryLinkForIdentityBody

        val localVariableQuery = mutableMapOf<String, List<String>>()
        returnTo?.apply { localVariableQuery["return_to"] = listOf("$returnTo") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/admin/recovery/link",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Delete an Identity
     * Calling this endpoint irrecoverably and permanently deletes the [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model) given its ID. This action can not be undone. This endpoint returns 204 when the identity was deleted or when the identity was not found, in which case it is assumed that is has been deleted already.
     * @param id ID is the identity&#39;s ID.
     * @return void
     */
    open suspend fun deleteIdentity(id: kotlin.String): HttpResponse<Unit> {

        val localVariableAuthNames = listOf<String>("oryAccessToken")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/admin/identities/{id}".replace("{" + "id" + "}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * enum for parameter type
     */
    @Serializable
    enum class TypeDeleteIdentityCredentials(val value: kotlin.String) {
        
        @SerialName(value = "password")
        PASSWORD("password"),
        
        @SerialName(value = "oidc")
        OIDC("oidc"),
        
        @SerialName(value = "totp")
        TOTP("totp"),
        
        @SerialName(value = "lookup_secret")
        LOOKUP_SECRET("lookup_secret"),
        
        @SerialName(value = "webauthn")
        WEBAUTHN("webauthn"),
        
        @SerialName(value = "code")
        CODE("code"),
        
        @SerialName(value = "passkey")
        PASSKEY("passkey"),
        
        @SerialName(value = "profile")
        PROFILE("profile"),
        
        @SerialName(value = "link_recovery")
        LINK_RECOVERY("link_recovery"),
        
        @SerialName(value = "code_recovery")
        CODE_RECOVERY("code_recovery")
        
    }

    /**
     * Delete a credential for a specific identity
     * Delete an [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model) credential by its type You can only delete second factor (aal2) credentials.
     * @param id ID is the identity&#39;s ID.
     * @param type Type is the type of credentials to be deleted. password CredentialsTypePassword oidc CredentialsTypeOIDC totp CredentialsTypeTOTP lookup_secret CredentialsTypeLookup webauthn CredentialsTypeWebAuthn code CredentialsTypeCodeAuth passkey CredentialsTypePasskey profile CredentialsTypeProfile link_recovery CredentialsTypeRecoveryLink  CredentialsTypeRecoveryLink is a special credential type linked to the link strategy (recovery flow).  It is not used within the credentials object itself. code_recovery CredentialsTypeRecoveryCode
     * @return void
     */
    open suspend fun deleteIdentityCredentials(id: kotlin.String, type: TypeDeleteIdentityCredentials): HttpResponse<Unit> {

        val localVariableAuthNames = listOf<String>("oryAccessToken")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/admin/identities/{id}/credentials/{type}".replace("{" + "id" + "}", "$id").replace("{" + "type" + "}", "$type"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Delete &amp; Invalidate an Identity&#39;s Sessions
     * Calling this endpoint irrecoverably and permanently deletes and invalidates all sessions that belong to the given Identity.
     * @param id ID is the identity&#39;s ID.
     * @return void
     */
    open suspend fun deleteIdentitySessions(id: kotlin.String): HttpResponse<Unit> {

        val localVariableAuthNames = listOf<String>("oryAccessToken")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/admin/identities/{id}/sessions".replace("{" + "id" + "}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Deactivate a Session
     * Calling this endpoint deactivates the specified session. Session data is not deleted.
     * @param id ID is the session&#39;s ID.
     * @return void
     */
    open suspend fun disableSession(id: kotlin.String): HttpResponse<Unit> {

        val localVariableAuthNames = listOf<String>("oryAccessToken")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/admin/sessions/{id}".replace("{" + "id" + "}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Extend a Session
     * Calling this endpoint extends the given session ID. If &#x60;session.earliest_possible_extend&#x60; is set it will only extend the session after the specified time has passed.  Retrieve the session ID from the &#x60;/sessions/whoami&#x60; endpoint / &#x60;toSession&#x60; SDK method.
     * @param id ID is the session&#39;s ID.
     * @return Session
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun extendSession(id: kotlin.String): HttpResponse<Session> {

        val localVariableAuthNames = listOf<String>("oryAccessToken")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PATCH,
            "/admin/sessions/{id}/extend".replace("{" + "id" + "}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * enum for parameter includeCredential
     */
    @Serializable
    enum class IncludeCredentialGetIdentity(val value: kotlin.String) {
        
        @SerialName(value = "password")
        PASSWORD("password"),
        
        @SerialName(value = "oidc")
        OIDC("oidc"),
        
        @SerialName(value = "totp")
        TOTP("totp"),
        
        @SerialName(value = "lookup_secret")
        LOOKUP_SECRET("lookup_secret"),
        
        @SerialName(value = "webauthn")
        WEBAUTHN("webauthn"),
        
        @SerialName(value = "code")
        CODE("code"),
        
        @SerialName(value = "passkey")
        PASSKEY("passkey"),
        
        @SerialName(value = "profile")
        PROFILE("profile"),
        
        @SerialName(value = "link_recovery")
        LINK_RECOVERY("link_recovery"),
        
        @SerialName(value = "code_recovery")
        CODE_RECOVERY("code_recovery")
        
    }

    /**
     * Get an Identity
     * Return an [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model) by its ID. You can optionally include credentials (e.g. social sign in connections) in the response by using the &#x60;include_credential&#x60; query parameter.
     * @param id ID must be set to the ID of identity you want to get
     * @param includeCredential Include Credentials in Response  Include any credential, for example &#x60;password&#x60; or &#x60;oidc&#x60;, in the response. When set to &#x60;oidc&#x60;, This will return the initial OAuth 2.0 Access Token, OAuth 2.0 Refresh Token and the OpenID Connect ID Token if available. (optional)
     * @return Identity
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getIdentity(id: kotlin.String, includeCredential: kotlin.collections.List<IncludeCredentialGetIdentity>? = null): HttpResponse<Identity> {

        val localVariableAuthNames = listOf<String>("oryAccessToken")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        includeCredential?.apply { localVariableQuery["include_credential"] = toMultiValue(this, "multi") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/admin/identities/{id}".replace("{" + "id" + "}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get Identity JSON Schema
     * Return a specific identity schema.
     * @param id ID must be set to the ID of schema you want to get
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getIdentitySchema(id: kotlin.String): HttpResponse<kotlin.String> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/schemas/{id}".replace("{" + "id" + "}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * enum for parameter expand
     */
    @Serializable
    enum class ExpandGetSession(val value: kotlin.String) {
        
        @SerialName(value = "identity")
        IDENTITY("identity"),
        
        @SerialName(value = "devices")
        DEVICES("devices")
        
    }

    /**
     * Get Session
     * This endpoint is useful for:  Getting a session object with all specified expandables that exist in an administrative context.
     * @param id ID is the session&#39;s ID.
     * @param expand ExpandOptions is a query parameter encoded list of all properties that must be expanded in the Session. Example - ?expand&#x3D;Identity&amp;expand&#x3D;Devices If no value is provided, the expandable properties are skipped. (optional)
     * @return Session
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getSession(id: kotlin.String, expand: kotlin.collections.List<ExpandGetSession>? = null): HttpResponse<Session> {

        val localVariableAuthNames = listOf<String>("oryAccessToken")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        expand?.apply { localVariableQuery["expand"] = toMultiValue(this, "multi") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/admin/sessions/{id}".replace("{" + "id" + "}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * enum for parameter consistency
     */
    @Serializable
    enum class ConsistencyListIdentities(val value: kotlin.String) {
        
        @SerialName(value = "")
        EMPTY(""),
        
        @SerialName(value = "strong")
        STRONG("strong"),
        
        @SerialName(value = "eventual")
        EVENTUAL("eventual")
        
    }

    /**
     * List Identities
     * Lists all [identities](https://www.ory.sh/docs/kratos/concepts/identity-user-model) in the system.
     * @param perPage Deprecated Items per Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This is the number of items per page. (optional, default to 250L)
     * @param page Deprecated Pagination Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This value is currently an integer, but it is not sequential. The value is not the page number, but a reference. The next page can be any number and some numbers might return an empty list.  For example, page 2 might not follow after page 1. And even if page 3 and 5 exist, but page 4 might not exist. The first page can be retrieved by omitting this parameter. Following page pointers will be returned in the &#x60;Link&#x60; header. (optional)
     * @param pageSize Page Size  This is the number of items per page to return. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to 250L)
     * @param pageToken Next Page Token  The next page token. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to "1")
     * @param consistency Read Consistency Level (preview)  The read consistency level determines the consistency guarantee for reads:  strong (slow): The read is guaranteed to return the most recent data committed at the start of the read. eventual (very fast): The result will return data that is about 4.8 seconds old.  The default consistency guarantee can be changed in the Ory Network Console or using the Ory CLI with &#x60;ory patch project --replace &#39;/previews/default_read_consistency_level&#x3D;\&quot;strong\&quot;&#39;&#x60;.  Setting the default consistency level to &#x60;eventual&#x60; may cause regressions in the future as we add consistency controls to more APIs. Currently, the following APIs will be affected by this setting:  &#x60;GET /admin/identities&#x60;  This feature is in preview and only available in Ory Network.  ConsistencyLevelUnset  ConsistencyLevelUnset is the unset / default consistency level. strong ConsistencyLevelStrong  ConsistencyLevelStrong is the strong consistency level. eventual ConsistencyLevelEventual  ConsistencyLevelEventual is the eventual consistency level using follower read timestamps. (optional)
     * @param ids List of ids used to filter identities. If this list is empty, then no filter will be applied. (optional)
     * @param credentialsIdentifier CredentialsIdentifier is the identifier (username, email) of the credentials to look up using exact match. Only one of CredentialsIdentifier and CredentialsIdentifierSimilar can be used. (optional)
     * @param previewCredentialsIdentifierSimilar This is an EXPERIMENTAL parameter that WILL CHANGE. Do NOT rely on consistent, deterministic behavior. THIS PARAMETER WILL BE REMOVED IN AN UPCOMING RELEASE WITHOUT ANY MIGRATION PATH.  CredentialsIdentifierSimilar is the (partial) identifier (username, email) of the credentials to look up using similarity search. Only one of CredentialsIdentifier and CredentialsIdentifierSimilar can be used. (optional)
     * @param includeCredential Include Credentials in Response  Include any credential, for example &#x60;password&#x60; or &#x60;oidc&#x60;, in the response. When set to &#x60;oidc&#x60;, This will return the initial OAuth 2.0 Access Token, OAuth 2.0 Refresh Token and the OpenID Connect ID Token if available. (optional)
     * @return kotlin.Array<Identity>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun listIdentities(perPage: kotlin.Long? = 250L, page: kotlin.Long? = null, pageSize: kotlin.Long? = 250L, pageToken: kotlin.String? = "1", consistency: ConsistencyListIdentities? = null, ids: kotlin.Array<kotlin.String>? = null, credentialsIdentifier: kotlin.String? = null, previewCredentialsIdentifierSimilar: kotlin.String? = null, includeCredential: kotlin.Array<kotlin.String>? = null): HttpResponse<kotlin.Array<Identity>> {

        val localVariableAuthNames = listOf<String>("oryAccessToken")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        perPage?.apply { localVariableQuery["per_page"] = listOf("$perPage") }
        page?.apply { localVariableQuery["page"] = listOf("$page") }
        pageSize?.apply { localVariableQuery["page_size"] = listOf("$pageSize") }
        pageToken?.apply { localVariableQuery["page_token"] = listOf("$pageToken") }
        consistency?.apply { localVariableQuery["consistency"] = listOf("$consistency") }
        ids?.apply { localVariableQuery["ids"] = toMultiValue(this, "multi") }
        credentialsIdentifier?.apply { localVariableQuery["credentials_identifier"] = listOf("$credentialsIdentifier") }
        previewCredentialsIdentifierSimilar?.apply { localVariableQuery["preview_credentials_identifier_similar"] = listOf("$previewCredentialsIdentifierSimilar") }
        includeCredential?.apply { localVariableQuery["include_credential"] = toMultiValue(this, "multi") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/admin/identities",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<ListIdentitiesResponse>().map { value.toTypedArray() }
    }

    @Serializable(ListIdentitiesResponse.Companion::class)
    private class ListIdentitiesResponse(val value: List<Identity>) {
        companion object : KSerializer<ListIdentitiesResponse> {
            private val serializer: KSerializer<List<Identity>> = serializer<List<Identity>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: ListIdentitiesResponse) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = ListIdentitiesResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * Get all Identity Schemas
     * Returns a list of all identity schemas currently in use.
     * @param perPage Deprecated Items per Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This is the number of items per page. (optional, default to 250L)
     * @param page Deprecated Pagination Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This value is currently an integer, but it is not sequential. The value is not the page number, but a reference. The next page can be any number and some numbers might return an empty list.  For example, page 2 might not follow after page 1. And even if page 3 and 5 exist, but page 4 might not exist. The first page can be retrieved by omitting this parameter. Following page pointers will be returned in the &#x60;Link&#x60; header. (optional)
     * @param pageSize Page Size  This is the number of items per page to return. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to 250L)
     * @param pageToken Next Page Token  The next page token. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to "1")
     * @return kotlin.Array<IdentitySchemaContainer>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun listIdentitySchemas(perPage: kotlin.Long? = 250L, page: kotlin.Long? = null, pageSize: kotlin.Long? = 250L, pageToken: kotlin.String? = "1"): HttpResponse<kotlin.Array<IdentitySchemaContainer>> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        perPage?.apply { localVariableQuery["per_page"] = listOf("$perPage") }
        page?.apply { localVariableQuery["page"] = listOf("$page") }
        pageSize?.apply { localVariableQuery["page_size"] = listOf("$pageSize") }
        pageToken?.apply { localVariableQuery["page_token"] = listOf("$pageToken") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/schemas",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<ListIdentitySchemasResponse>().map { value.toTypedArray() }
    }

    @Serializable(ListIdentitySchemasResponse.Companion::class)
    private class ListIdentitySchemasResponse(val value: List<IdentitySchemaContainer>) {
        companion object : KSerializer<ListIdentitySchemasResponse> {
            private val serializer: KSerializer<List<IdentitySchemaContainer>> = serializer<List<IdentitySchemaContainer>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: ListIdentitySchemasResponse) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = ListIdentitySchemasResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * List an Identity&#39;s Sessions
     * This endpoint returns all sessions that belong to the given Identity.
     * @param id ID is the identity&#39;s ID.
     * @param perPage Deprecated Items per Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This is the number of items per page. (optional, default to 250L)
     * @param page Deprecated Pagination Page  DEPRECATED: Please use &#x60;page_token&#x60; instead. This parameter will be removed in the future.  This value is currently an integer, but it is not sequential. The value is not the page number, but a reference. The next page can be any number and some numbers might return an empty list.  For example, page 2 might not follow after page 1. And even if page 3 and 5 exist, but page 4 might not exist. The first page can be retrieved by omitting this parameter. Following page pointers will be returned in the &#x60;Link&#x60; header. (optional)
     * @param pageSize Page Size  This is the number of items per page to return. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to 250L)
     * @param pageToken Next Page Token  The next page token. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to "1")
     * @param active Active is a boolean flag that filters out sessions based on the state. If no value is provided, all sessions are returned. (optional)
     * @return kotlin.Array<Session>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun listIdentitySessions(id: kotlin.String, perPage: kotlin.Long? = 250L, page: kotlin.Long? = null, pageSize: kotlin.Long? = 250L, pageToken: kotlin.String? = "1", active: kotlin.Boolean? = null): HttpResponse<kotlin.Array<Session>> {

        val localVariableAuthNames = listOf<String>("oryAccessToken")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        perPage?.apply { localVariableQuery["per_page"] = listOf("$perPage") }
        page?.apply { localVariableQuery["page"] = listOf("$page") }
        pageSize?.apply { localVariableQuery["page_size"] = listOf("$pageSize") }
        pageToken?.apply { localVariableQuery["page_token"] = listOf("$pageToken") }
        active?.apply { localVariableQuery["active"] = listOf("$active") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/admin/identities/{id}/sessions".replace("{" + "id" + "}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<ListIdentitySessionsResponse>().map { value.toTypedArray() }
    }

    @Serializable(ListIdentitySessionsResponse.Companion::class)
    private class ListIdentitySessionsResponse(val value: List<Session>) {
        companion object : KSerializer<ListIdentitySessionsResponse> {
            private val serializer: KSerializer<List<Session>> = serializer<List<Session>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: ListIdentitySessionsResponse) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = ListIdentitySessionsResponse(serializer.deserialize(decoder))
        }
    }


    /**
     * enum for parameter expand
     */
    @Serializable
    enum class ExpandListSessions(val value: kotlin.String) {
        
        @SerialName(value = "identity")
        IDENTITY("identity"),
        
        @SerialName(value = "devices")
        DEVICES("devices")
        
    }

    /**
     * List All Sessions
     * Listing all sessions that exist.
     * @param pageSize Items per Page  This is the number of items per page to return. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional, default to 250L)
     * @param pageToken Next Page Token  The next page token. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination). (optional)
     * @param active Active is a boolean flag that filters out sessions based on the state. If no value is provided, all sessions are returned. (optional)
     * @param expand ExpandOptions is a query parameter encoded list of all properties that must be expanded in the Session. If no value is provided, the expandable properties are skipped. (optional)
     * @return kotlin.Array<Session>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun listSessions(pageSize: kotlin.Long? = 250L, pageToken: kotlin.String? = null, active: kotlin.Boolean? = null, expand: kotlin.collections.List<ExpandListSessions>? = null): HttpResponse<kotlin.Array<Session>> {

        val localVariableAuthNames = listOf<String>("oryAccessToken")

        val localVariableBody = 
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        pageSize?.apply { localVariableQuery["page_size"] = listOf("$pageSize") }
        pageToken?.apply { localVariableQuery["page_token"] = listOf("$pageToken") }
        active?.apply { localVariableQuery["active"] = listOf("$active") }
        expand?.apply { localVariableQuery["expand"] = toMultiValue(this, "multi") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/admin/sessions",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<ListSessionsResponse>().map { value.toTypedArray() }
    }

    @Serializable(ListSessionsResponse.Companion::class)
    private class ListSessionsResponse(val value: List<Session>) {
        companion object : KSerializer<ListSessionsResponse> {
            private val serializer: KSerializer<List<Session>> = serializer<List<Session>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: ListSessionsResponse) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = ListSessionsResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * Patch an Identity
     * Partially updates an [identity&#39;s](https://www.ory.sh/docs/kratos/concepts/identity-user-model) field using [JSON Patch](https://jsonpatch.com/). The fields &#x60;id&#x60;, &#x60;stateChangedAt&#x60; and &#x60;credentials&#x60; can not be updated using this method.
     * @param id ID must be set to the ID of identity you want to update
     * @param jsonPatch  (optional)
     * @return Identity
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun patchIdentity(id: kotlin.String, jsonPatch: kotlin.Array<JsonPatch>? = null): HttpResponse<Identity> {

        val localVariableAuthNames = listOf<String>("oryAccessToken")

        val localVariableBody = PatchIdentityRequest(jsonPatch?.asList() ?: arrayListOf())

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PATCH,
            "/admin/identities/{id}".replace("{" + "id" + "}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }

    @Serializable(PatchIdentityRequest.Companion::class)
    private class PatchIdentityRequest(val value: List<JsonPatch>) {
        companion object : KSerializer<PatchIdentityRequest> {
            private val serializer: KSerializer<List<JsonPatch>> = serializer<List<JsonPatch>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, obj: PatchIdentityRequest) = serializer.serialize(encoder, obj.value)
            override fun deserialize(decoder: Decoder) = PatchIdentityRequest(serializer.deserialize(decoder))
        }
    }

    /**
     * Update an Identity
     * This endpoint updates an [identity](https://www.ory.sh/docs/kratos/concepts/identity-user-model). The full identity payload (except credentials) is expected. It is possible to update the identity&#39;s credentials as well.
     * @param id ID must be set to the ID of identity you want to update
     * @param updateIdentityBody  (optional)
     * @return Identity
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun updateIdentity(id: kotlin.String, updateIdentityBody: UpdateIdentityBody? = null): HttpResponse<Identity> {

        val localVariableAuthNames = listOf<String>("oryAccessToken")

        val localVariableBody = updateIdentityBody

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/admin/identities/{id}".replace("{" + "id" + "}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



}
